AWSTemplateFormatVersion: 2010-09-09
Description: 'CBS: Create a CBS array Template Version: 202110200459+eefec2eede9e-62x'
Parameters:
  KeyName:
    Description: Required. Name of an existing EC2 KeyPair to enable SSH access to
      the controllers.
    Type: AWS::EC2::KeyPair::KeyName
  SystemSubnet:
    Description: Required. Subnet in which to launch system interfaces (internal to
      the array).
    Type: AWS::EC2::Subnet::Id
  ReplicationSubnet:
    Description: Required. Subnet in which to launch replication interfaces.
    Type: AWS::EC2::Subnet::Id
  ISCSISubnet:
    Description: Required. Subnet in which to launch iSCSI interfaces.
    Type: AWS::EC2::Subnet::Id
  ManagementSubnet:
    Description: Required. Subnet in which to launch management interfaces.
    Type: AWS::EC2::Subnet::Id
  ReplicationSecurityGroup:
    Description: Required. Security Group to apply to replication interfaces. Must
      allow inbound and outbound TCP traffic on ports 8117.
    Type: AWS::EC2::SecurityGroup::Id
  ISCSISecurityGroup:
    Description: Required. Security Group to apply to iSCSI interfaces. Must allow
      inbound TCP traffic on port 3260.
    Type: AWS::EC2::SecurityGroup::Id
  ManagementSecurityGroup:
    Description: Required. Security Group to apply to management interfaces. Must
      allow inbound TCP traffic on ports 22, 80, 8084, and inbound/outbound on port
      443.
    Type: AWS::EC2::SecurityGroup::Id
  InstanceTenancy:
    Description: Required. Choose to launch Purity controllers on dedicated instances.
    Type: String
    AllowedValues:
    - default
    - dedicated
    Default: default
  EncryptVolumesWithDefaultKey:
    Description: Optional. If true, encrypts EBS Volumes with the default CMK for
      the deployment region of the array. If false, encrypts the EBS Volumes with
      the AWS managed CMK for EBS (alias/aws/ebs). Defaults to false. Note that before
      setting to true, ensure that the default CMK access policy grants access to
      the default service-linked role for AWS AutoScaling, which is typically AWSServiceRoleForAutoScaling.
    Type: String
    AllowedValues:
    - true
    - false
    Default: false
  ArrayName:
    Description: Required. Name of the array, can be modified later using purearray.
    Type: String
    AllowedPattern: (?!-)[a-zA-Z0-9-]{1,63}(?<!-)
    MaxLength: 63
    ConstraintDescription: Must begin with a letter and contain only alphanumeric
      characters.
  LogSenderDomain:
    Description: Required. Domain name used to determine how CBS logs are parsed and
      treated by Pure Storage Support and Escalations. The domain is also used in
      alert email messages. Can be modified later using purearray.
    Type: String
    AllowedPattern: ((?!-)[a-zA-Z0-9-]{1,63}(?<!-)(\.|$)){2,}
    ConstraintDescription: Must be a valid domain address.
  AlertRecipients:
    Description: Recommended. Comma separated list of email addresses to receive alerts,
      can be modified later using purealert.
    Type: CommaDelimitedList
  PurityInstanceType:
    Description: Required. CBS array size to launch.
    Type: String
    AllowedValues:
    - V10AR1
    - V20AR1
    Default: V10AR1
  LicenseKey:
    Description: Required. Pure provided license key for production or "CBS-TRIAL-LICENSE"
      for a trial array.
    Type: String
  AdminArn:
    Description: Pure Storage internal, do not use. Administrator ARN used for CBS
      terraform provider authentication.
    Type: String
    Default: ''
  CustomCT0AMI:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  CustomCT1AMI:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  CustomCT0InstanceType:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  CustomCT1InstanceType:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  CustomNVRAMVolumeType:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  CustomNVRAMIOPs:
    Description: Pure Storage internal, do not use.
    Type: Number
    Default: 0
  CreateCT0:
    Description: Pure Storage internal, do not use.
    Type: Number
    AllowedValues:
    - 0
    - 1
    Default: 1
  CreateCT1:
    Description: Pure Storage internal, do not use.
    Type: Number
    AllowedValues:
    - 0
    - 1
    Default: 1
  ReplicationSubnetCT0:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  ReplicationSubnetCT1:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  ISCSISubnetCT0:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  ISCSISubnetCT1:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  InitialDeploymentCT0:
    Description: Pure Storage internal, do not use.
    Type: Number
    AllowedValues:
    - 0
    - 1
    Default: 1
  InitialDeploymentCT1:
    Description: Pure Storage internal, do not use.
    Type: Number
    AllowedValues:
    - 0
    - 1
    Default: 1
  CreateVDGroup1:
    Description: Pure Storage internal, do not use.
    Type: Number
    AllowedValues:
    - 0
    - 1
    Default: 0
  CreateVDGroup2:
    Description: Pure Storage internal, do not use.
    Type: Number
    AllowedValues:
    - 0
    - 1
    Default: 0
  CreateVDGroup3:
    Description: Pure Storage internal, do not use.
    Type: Number
    AllowedValues:
    - 0
    - 1
    Default: 0
  ReplicationAddressCT0:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  ReplicationAddressCT1:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  ISCSIAddressCT0:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  ISCSIAddressCT1:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  ManagementAddress:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  VDInstanceFamily:
    Description: Pure Storage internal, do not use.
    Type: String
    AllowedValues:
    - i3
    - i3en
    - i3enV20i3V10
    Default: i3enV20i3V10
  AULiveSetTableMinWCU:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  AULiveSetTableMinRCU:
    Description: Pure Storage internal, do not use.
    Type: String
    Default: ''
  AULiveSetTableRemoval:
    Description: Whether the array is using an AULiveSetTable. Will be deleted if
      set to 'removed'
    Type: String
    AllowedValues:
    - in_use
    - removed
    Default: removed
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Purity Configuration
      Parameters:
      - ArrayName
      - LogSenderDomain
      - PurityInstanceType
      - LicenseKey
      - AlertRecipients
    - Label:
        default: Network and Security Configuration
      Parameters:
      - KeyName
      - SystemSubnet
      - ReplicationSubnet
      - ISCSISubnet
      - ManagementSubnet
      - ReplicationSecurityGroup
      - ISCSISecurityGroup
      - ManagementSecurityGroup
      - InstanceTenancy
      - EncryptVolumesWithDefaultKey
    - Label:
        default: Pure Storage Internal Configuration - DO NOT USE
      Parameters:
      - CustomCT0AMI
      - CustomCT1AMI
      - CustomCT0InstanceType
      - CustomCT1InstanceType
      - CustomNVRAMVolumeType
      - CustomNVRAMIOPs
      - CreateCT0
      - CreateCT1
      - ReplicationSubnetCT0
      - ReplicationSubnetCT1
      - ISCSISubnetCT0
      - ISCSISubnetCT1
      - InitialDeploymentCT0
      - InitialDeploymentCT1
      - CreateVDGroup1
      - CreateVDGroup2
      - CreateVDGroup3
      - ReplicationAddressCT0
      - ReplicationAddressCT1
      - ISCSIAddressCT0
      - ISCSIAddressCT1
      - ManagementAddress
      - VDInstanceFamily
      - AULiveSetTableMinWCU
      - AULiveSetTableMinRCU
      - AULiveSetTableRemoval
Mappings:
  Constants:
    PhoneHomeAddresses:
      Value:
      - rest.cloud-support.purestorage.com
      - ra.cloud-support.purestorage.com
    PhonehomeCidrIp:
      Value: 52.40.255.224/27
  V20AR1:
    nvram:
      iops: 6000
    io2:
      nvramtype: io2
      nvramsize: 12
    io1:
      nvramtype: io1
      nvramsize: 120
    controller-instance:
      type: c5n.18xlarge
    vd-instance:
      i3: i3.4xlarge
      i3en: i3en.3xlarge
    AULiveSetTable:
      MinWCU: 2000
      MinRCU: 1000
      MaxWCU: 10000
      MaxRCU: 10000
      DisabledCapacityUnits: 1
    num-vds:
      count: 7
  V10AR1:
    nvram:
      iops: 3000
    io2:
      nvramtype: io2
      nvramsize: 6
    io1:
      nvramtype: io1
      nvramsize: 60
    controller-instance:
      type: c5n.9xlarge
    vd-instance:
      i3: i3.2xlarge
      i3en: i3en.xlarge
    AULiveSetTable:
      MinWCU: 1000
      MinRCU: 500
      MaxWCU: 10000
      MaxRCU: 10000
      DisabledCapacityUnits: 1
    num-vds:
      count: 7
  AWSRegion2AMI:
    ap-northeast-1:
      Value: ami-046e8b59b593a07d2
    ap-northeast-2:
      Value: ami-0f4f0166ced931541
    ap-south-1:
      Value: ami-0e3474a6491b27dfb
    ap-southeast-1:
      Value: ami-07b11a713c13eb832
    ap-southeast-2:
      Value: ami-091bd23fff6ab9150
    ca-central-1:
      Value: ami-0c588e9b1b87b3a0f
    eu-central-1:
      Value: ami-0868d148c5f791ff3
    eu-north-1:
      Value: ami-08e13762364367e74
    eu-west-1:
      Value: ami-04b965a27ab639fa3
    eu-west-2:
      Value: ami-0916fc3ebbc3a60e4
    eu-west-3:
      Value: ami-0ab7996a5d4c3017a
    sa-east-1:
      Value: ami-0e033159fde4d4d33
    us-east-1:
      Value: ami-0f52b45e433f9cad0
    us-east-2:
      Value: ami-034d9760dd39e788c
    us-west-1:
      Value: ami-011afd455dd264a7d
    us-west-2:
      Value: ami-03fa925156667747f
    ap-northeast-3:
      Value: ami-08b0646e4222287f2
    ap-east-1:
      Value: ami-06337f439bb0624e2
    me-south-1:
      Value: ami-05eb6185d78bef91f
    af-south-1:
      Value: ami-07b5146d5bfc00bf9
    eu-south-1:
      Value: ami-0ea352b69536f433d
    us-gov-east-1:
      Value: ami-0cd6896ead619a02f
    us-gov-west-1:
      Value: ami-0a2f3a5f64614efa0

  AWSRegion2HW:
    ap-northeast-1:
      nvramtype: io2
      vdinstancefamily: i3en
    ap-northeast-2:
      nvramtype: io2
      vdinstancefamily: i3en
    ap-south-1:
      nvramtype: io2
      vdinstancefamily: i3en
    ap-southeast-1:
      nvramtype: io2
      vdinstancefamily: i3en
    ap-southeast-2:
      nvramtype: io2
      vdinstancefamily: i3en
    ca-central-1:
      nvramtype: io2
      vdinstancefamily: i3en
    eu-central-1:
      nvramtype: io2
      vdinstancefamily: i3en
    eu-west-1:
      nvramtype: io2
      vdinstancefamily: i3en
    eu-west-2:
      nvramtype: io2
      vdinstancefamily: i3en
    eu-west-3:
      nvramtype: io1
      vdinstancefamily: i3en
    eu-north-1:
      nvramtype: io2
      vdinstancefamily: i3en
    sa-east-1:
      nvramtype: io1
      vdinstancefamily: i3en
    us-east-1:
      nvramtype: io2
      vdinstancefamily: i3en
    us-east-2:
      nvramtype: io2
      vdinstancefamily: i3en
    us-west-1:
      nvramtype: io2
      vdinstancefamily: i3en
    us-west-2:
      nvramtype: io2
      vdinstancefamily: i3en
    us-gov-east-1:
      nvramtype: io1
      vdinstancefamily: i3
    us-gov-west-1:
      nvramtype: io1
      vdinstancefamily: i3en
    ap-northeast-3:
      nvramtype: io2
      vdinstancefamily: i3en
    ap-east-1:
      nvramtype: io2
      vdinstancefamily: i3en
    me-south-1:
      nvramtype: io2
      vdinstancefamily: i3en
    af-south-1:
      nvramtype: io2
      vdinstancefamily: i3en
    eu-south-1:
      nvramtype: io2
      vdinstancefamily: i3en
Conditions:
  IsAdminArn: !Not [!Equals [!Ref 'AdminArn', '']]
  IsCustomCT0AMI: !Not [!Equals [!Ref 'CustomCT0AMI', '']]
  IsCustomCT1AMI: !Not [!Equals [!Ref 'CustomCT1AMI', '']]
  IsCustomCT0InstanceType: !Not [!Equals [!Ref 'CustomCT0InstanceType', '']]
  IsCustomCT1InstanceType: !Not [!Equals [!Ref 'CustomCT1InstanceType', '']]
  IsCustomNVRAMVolumeType: !Not [!Equals [!Ref 'CustomNVRAMVolumeType', '']]
  IsCustomNVRAMIOPs: !Not [!Equals [!Ref 'CustomNVRAMIOPs', 0]]
  IsCreateCT0: !Equals [!Ref 'CreateCT0', 1]
  IsCreateCT1: !Equals [!Ref 'CreateCT1', 1]
  IsCustomReplicationSubnetCT0: !Not [!Equals [!Ref 'ReplicationSubnetCT0', '']]
  IsCustomReplicationSubnetCT1: !Not [!Equals [!Ref 'ReplicationSubnetCT1', '']]
  IsCustomISCSISubnetCT0: !Not [!Equals [!Ref 'ISCSISubnetCT0', '']]
  IsCustomISCSISubnetCT1: !Not [!Equals [!Ref 'ISCSISubnetCT1', '']]
  IsEncryptWithDefaultKey: !Equals [!Ref 'EncryptVolumesWithDefaultKey', true]
  IsInitialDeploymentCT0: !Equals [!Ref 'InitialDeploymentCT0', 1]
  IsInitialDeploymentCT1: !Equals [!Ref 'InitialDeploymentCT1', 1]
  IsCreateVDGroup1: !Equals [!Ref 'CreateVDGroup1', 1]
  IsCreateVDGroup2: !Equals [!Ref 'CreateVDGroup2', 1]
  IsCreateVDGroup3: !Equals [!Ref 'CreateVDGroup3', 1]
  IsCustomReplicationAddressCT0: !Not [!Equals [!Ref 'ReplicationAddressCT0', '']]
  IsCustomReplicationAddressCT1: !Not [!Equals [!Ref 'ReplicationAddressCT1', '']]
  IsCustomISCSIAddressCT0: !Not [!Equals [!Ref 'ISCSIAddressCT0', '']]
  IsCustomISCSIAddressCT1: !Not [!Equals [!Ref 'ISCSIAddressCT1', '']]
  IsCustomManagementAddress: !Not [!Equals [!Ref 'ManagementAddress', '']]
  IsVDi3enFamily: !And [!Or [!Equals [!Ref 'VDInstanceFamily', i3en], !And [!Equals [
          !Ref 'VDInstanceFamily', i3enV20i3V10], !Equals [!Ref 'PurityInstanceType',
          V20AR1]]], !Equals [!FindInMap [AWSRegion2HW, !Ref 'AWS::Region', vdinstancefamily],
      i3en]]
  IsDedicatedInstance: !Equals [!Ref 'InstanceTenancy', dedicated]
  IsCustomAULiveSetTableMinWCU: !Not [!Equals [!Ref 'AULiveSetTableMinWCU', '']]
  IsCustomAULiveSetTableMinRCU: !Not [!Equals [!Ref 'AULiveSetTableMinRCU', '']]
  IsUsingAULiveSetTable: !Equals [!Ref 'AULiveSetTableRemoval', in_use]
Resources:
  VPCRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
      Policies:
      - PolicyName: LambdaPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - ec2:DescribeInstances
            - ec2:DescribeSubnets
            - ec2:DescribeSecurityGroups
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            Resource: '*'
          - Effect: Allow
            Action:
            - cloudformation:ListStackResources
            Resource: !Ref 'AWS::StackId'
  VPCInfo:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'VPCRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "import cfnresponse\nimport boto3\n\ndef handler(event, context):\n\
          \  ec2 = boto3.resource('ec2', region_name=event['ResourceProperties']['Region'])\n\
          \  subnet = ec2.Subnet(event['ResourceProperties']['SubnetId'])\n  responseData\
          \ = {}\n  responseData['vpcid'] = subnet.vpc_id\n  responseData['az'] =\
          \ subnet.availability_zone\n  cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ responseData)\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 20
  VPCInfoCall:
    Type: Custom::VPCInfoCall
    Properties:
      ServiceToken: !GetAtt 'VPCInfo.Arn'
      SubnetId: !Ref 'SystemSubnet'
      Region: !Ref 'AWS::Region'
  PureSystemSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: System interface
      VpcId: !GetAtt 'VPCInfoCall.vpcid'
      SecurityGroupEgress:
      - IpProtocol: 6
        FromPort: 443
        ToPort: 443
        CidrIp: 0.0.0.0/0
        Description: HTTPS
      - IpProtocol: 6
        FromPort: 443
        ToPort: 443
        CidrIpv6: ::/0
        Description: HTTPS
      - IpProtocol: 6
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
        Description: On-Prem Mediator & Proxy Server
      - IpProtocol: 6
        FromPort: 80
        ToPort: 80
        CidrIpv6: ::/0
        Description: On-Prem Mediator & Proxy Server
      - IpProtocol: 6
        FromPort: 53
        ToPort: 53
        CidrIp: 0.0.0.0/0
        Description: DNS
      - IpProtocol: 6
        FromPort: 53
        ToPort: 53
        Description: DNS
        CidrIpv6: ::/0
      - IpProtocol: 6
        FromPort: 43
        ToPort: 43
        CidrIp: 0.0.0.0/0
        Description: DNS
      - IpProtocol: 6
        FromPort: 43
        ToPort: 43
        CidrIpv6: ::/0
        Description: DNS
      - IpProtocol: 17
        FromPort: 53
        ToPort: 53
        CidrIp: 0.0.0.0/0
        Description: DNS
      - IpProtocol: 17
        FromPort: 53
        ToPort: 53
        CidrIpv6: ::/0
        Description: DNS
      - IpProtocol: 17
        FromPort: 43
        ToPort: 43
        CidrIp: 0.0.0.0/0
        Description: DNS
      - IpProtocol: 17
        FromPort: 43
        ToPort: 43
        CidrIpv6: ::/0
        Description: DNS
      - IpProtocol: 6
        FromPort: 389
        ToPort: 389
        CidrIp: 0.0.0.0/0
        Description: Directory Services
      - IpProtocol: 6
        FromPort: 389
        ToPort: 389
        CidrIpv6: ::/0
        Description: Directory Services
      - IpProtocol: 6
        FromPort: 636
        ToPort: 636
        CidrIp: 0.0.0.0/0
        Description: Directory Services
      - IpProtocol: 6
        FromPort: 636
        ToPort: 636
        CidrIpv6: ::/0
        Description: Directory Services
      - IpProtocol: 17
        FromPort: 123
        ToPort: 123
        CidrIp: 0.0.0.0/0
        Description: NTP
      - IpProtocol: 17
        FromPort: 123
        ToPort: 123
        CidrIpv6: ::/0
        Description: NTP
      - IpProtocol: 6
        FromPort: 587
        ToPort: 587
        CidrIp: 0.0.0.0/0
        Description: Email
      - IpProtocol: 6
        FromPort: 587
        ToPort: 587
        CidrIpv6: ::/0
        Description: Email
      Tags:
      - Key: Product
        Value: Pure:CBS
  PureSystemSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref 'PureSystemSecurityGroup'
      SourceSecurityGroupId: !Ref 'PureSystemSecurityGroup'
      IpProtocol: -1
      FromPort: -1
      ToPort: -1
  PureSystemSecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !Ref 'PureSystemSecurityGroup'
      DestinationSecurityGroupId: !Ref 'PureSystemSecurityGroup'
      IpProtocol: -1
      FromPort: -1
      ToPort: -1
  SecurityGroupCheckup:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'VPCRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "import cfnresponse\nimport boto3\n\ndef handler(event, context):\n\
          \  responseData = {}\n  viablePorts = cfnresponse.SUCCESS\n  ec2 = boto3.resource('ec2',\
          \ region_name=event['ResourceProperties']['Region'])\n\n  port_dict = {'iSCSI':\
          \ {'tcp': [3260]}, 'Management': {'tcp': [22, 80, 443, 8084]}, 'Replication':\
          \ {'tcp': [8117]}}\n  protocol_dict = {'1': 'icmp', '6': 'tcp', '17': 'udp'}\n\
          \n  for frontend in port_dict:\n    group = ec2.SecurityGroup(event['ResourceProperties'][frontend\
          \ + 'Group'])\n    for ip_protocol, ports in port_dict[frontend].items():\n\
          \      tempports = ports[:]\n      for perm in group.ip_permissions:\n \
          \       perm_protocol = perm['IpProtocol']\n        if perm_protocol ==\
          \ '-1':\n          tempports = []\n          break\n        perm_protocol\
          \ = protocol_dict.get(perm_protocol, perm_protocol)\n        if perm_protocol\
          \ != ip_protocol:\n          continue\n        from_port = perm['FromPort']\n\
          \        to_port = perm['ToPort']\n        for port in ports:\n        \
          \  if port >= from_port and port <= to_port:\n            tempports.remove(port)\n\
          \      if tempports:\n        print('No inbound {} rule found for {} port(s):\
          \ {}'.format(ip_protocol, frontend, repr(tempports)))\n        viablePorts\
          \ = cfnresponse.FAILED\n  cfnresponse.send(event, context, viablePorts,\
          \ responseData)\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 20
  SecurityGroupCheckupCall:
    Type: Custom::SecurityGroupCheckupCall
    Properties:
      ServiceToken: !GetAtt 'SecurityGroupCheckup.Arn'
      Region: !Ref 'AWS::Region'
      iSCSIGroup: !Ref 'ISCSISecurityGroup'
      ManagementGroup: !Ref 'ManagementSecurityGroup'
      ReplicationGroup: !Ref 'ReplicationSecurityGroup'
  SubnetCheckup:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'VPCRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "import cfnresponse\nimport telnetlib\n\ndef handler(event, context):\n\
          \  responseData = {}\n  ph_addresses = event['ResourceProperties']['PhAddresses']\n\
          \  viableSubnet = cfnresponse.SUCCESS\n  for addr in ph_addresses:\n   \
          \ tn = telnetlib.Telnet()\n    try:\n      tn.open(host=addr, port=443,\
          \ timeout=90)\n    except Exception as e:\n      print('Error opening telnet\
          \ connection to {}: {}', addr, e)\n      viableSubnet = cfnresponse.FAILED\n\
          \      break\n    tn.close()\n  cfnresponse.send(event, context, viableSubnet,\
          \ responseData)\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 180
      VpcConfig:
        SecurityGroupIds:
        - !Ref 'PureSystemSecurityGroup'
        SubnetIds:
        - !Ref 'SystemSubnet'
  SubnetCheckupCall:
    Type: Custom::SubnetCheckupCall
    Properties:
      ServiceToken: !GetAtt 'SubnetCheckup.Arn'
      PhAddresses: !FindInMap [Constants, PhoneHomeAddresses, Value]
  MakeArrayID:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'VPCRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "import boto3\nimport cfnresponse\nimport json\nimport logging\n\n\
          logger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\ndef handler(event,\
          \ context):\n\n    try:\n        logger.info(\"Received event: \" + json.dumps(event,\
          \ indent=2))\n        assert event['ResourceProperties'].get('StackId')\
          \ != None\n        stack_id = event['ResourceProperties'].get('StackId')\n\
          \        hostname = event['ResourceProperties'].get('Host')\n        account_id\
          \ = event['ResourceProperties'].get('AccountId')\n\n        cfn = boto3.client('cloudformation')\n\
          \        ec2 = boto3.client('ec2')\n        resources = cfn.list_stack_resources(StackName=stack_id).get(\n\
          \          'StackResourceSummaries', []\n        )\n        instances =\
          \ [i['PhysicalResourceId'] for i in resources if\n          i.get('ResourceType')\
          \ == 'AWS::EC2::Instance']\n        if len(instances) > 0:\n          instance_states\
          \ = [s['Instances'][0] for s in ec2.describe_instances(InstanceIds=instances).get(\n\
          \            'Reservations', [])]\n          for state in instance_states:\n\
          \            tags = state.get('Tags',[])\n            for tag in tags:\n\
          \              if tag['Key'] == 'PS_ARRAY_ID':\n                print('Found\
          \ existing array id: ' + tag['Value'])\n                responseData = {\
          \ 'id' : tag['Value'] }\n                cfnresponse.send(event, context,\
          \ cfnresponse.SUCCESS, responseData)\n                return\n\n       \
          \ import hashlib\n        md5 = hashlib.md5()\n        md5.update('{}{}'.format(account_id,\
          \ hostname).encode('utf-8'))\n\n        from os import urandom\n       \
          \ md5.update(urandom(128))\n\n        digest = md5.hexdigest()\n       \
          \ net_id = int(digest, 16) & 0x3fffff\n        fc_id = int(digest, 16) >>\
          \ 22 & 0xfffffff\n        iscsi_id = int(digest, 16) >> (28 + 22) & 0x7fffffffffffffff\n\
          \        responseData = { 'id' : '{}-{}-{}'.format(net_id, fc_id, iscsi_id)\
          \ }\n        cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)\n\
          \    except Exception as e:\n        logger.error(\"Error occurred while\
          \ handling event: {}\".format(e))\n        cfnresponse.send(event, context,\
          \ cfnresponse.FAILED, {'Exception': str(e)})\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 20
  MakeArrayIDCall:
    Type: Custom::MakeArrayIDCall
    Properties:
      ServiceToken: !GetAtt 'MakeArrayID.Arn'
      Host: !Ref 'ArrayName'
      AccountId: !Ref 'AWS::AccountId'
      StackId: !Ref 'AWS::StackId'
  MakeAptID:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'VPCRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "import boto3\nimport cfnresponse\nimport json\nimport logging\n\
          import uuid\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\
          \ndef handler(event, context):\n\n    try:\n        logger.info(\"Received\
          \ event: \" + json.dumps(event, indent=2))\n        cfn = boto3.client('cloudformation')\n\
          \        ec2 = boto3.client('ec2')\n        assert event['ResourceProperties'].get('StackId')\
          \ != None\n        stack_id = event['ResourceProperties'].get('StackId')\n\
          \        print(\"stack_id: \" + stack_id)\n        resources = cfn.list_stack_resources(StackName=stack_id).get(\n\
          \          'StackResourceSummaries', []\n        )\n        instances =\
          \ [i['PhysicalResourceId'] for i in resources if\n          i.get('ResourceType')\
          \ == 'AWS::EC2::Instance']\n        if len(instances) > 0:\n          instance_states\
          \ = [s['Instances'][0] for s in ec2.describe_instances(InstanceIds=instances).get(\n\
          \            'Reservations', [])]\n          for state in instance_states:\n\
          \            tags = state.get('Tags',[])\n            for tag in tags:\n\
          \              if tag['Key'] == 'PS_CLOUD_APT_ID':\n                print('Existing\
          \ apt id found: ' + tag['Value'])\n                responseData = { 'id'\
          \ : tag['Value'] }\n                cfnresponse.send(event, context, cfnresponse.SUCCESS,\
          \ responseData)\n                return\n\n        responseData = {'id':\
          \ str(uuid.uuid4())}\n        print('Made up a new id: ' + responseData['id'])\n\
          \        cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData)\n\
          \    except Exception as e:\n        logger.error(\"Error occurred while\
          \ handling event: {}\".format(e))\n        cfnresponse.send(event, context,\
          \ cfnresponse.FAILED, {'Exception': str(e)})\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 20
  MakeAptIDCall:
    Type: Custom::MakeAptIDCall
    Properties:
      ServiceToken: !GetAtt 'MakeAptID.Arn'
      SubnetId: !Ref 'SystemSubnet'
      Region: !Ref 'AWS::Region'
      StackId: !Ref 'AWS::StackId'
  PureDataSecurityKey:
    Type: AWS::KMS::Key
    Properties:
      Description: Data security key
      Enabled: true
      PendingWindowInDays: 7
      KeyPolicy:
        Version: '2012-10-17'
        Id: !Join ['-', [!Ref 'ArrayName', dsk]]
        Statement:
        - Sid: Enable IAM User Permissions
          Effect: Allow
          Principal:
            AWS: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:root'
          Action: kms:*
          Resource: '*'
        - Sid: Allow administration of the key
          Effect: Allow
          Principal:
            AWS: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${PurityInstanceRole}'
          Action:
          - kms:CancelKeyDeletion
          - kms:Create*
          - kms:Delete*
          - kms:Describe*
          - kms:Disable*
          - kms:Enable*
          - kms:Get*
          - kms:List*
          - kms:Put*
          - kms:Revoke*
          - kms:ScheduleKeyDeletion
          - kms:Update*
          Resource: '*'
        - Sid: Allow use of the key
          Effect: Allow
          Principal:
            AWS: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${PurityInstanceRole}'
          Action:
          - kms:Decrypt
          - kms:DescribeKey
          - kms:Encrypt
          - kms:ReEncrypt*
          Resource: '*'
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'ArrayName', dsk]]
      - Key: Product
        Value: Pure:CBS
  PureDataSecurityKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Join ['-', [alias/pure, !GetAtt 'MakeAptIDCall.id', dsk]]
      TargetKeyId: !Ref 'PureDataSecurityKey'
  ArrayBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      BucketName: !Join ['-', [pure, !GetAtt 'MakeAptIDCall.id']]
      VersioningConfiguration:
        Status: Enabled
      Tags:
      - Key: Product
        Value: Pure:CBS
  AdminSecret:
    Condition: IsAdminArn
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: Administration credentials used by CBS terraform provider
      Name: !Sub 'pure/cbs/${MakeAptIDCall.id}'
      Tags:
      - Key: Product
        Value: Pure:CBS
  AdminSecretPolicy:
    Condition: IsAdminArn
    Type: AWS::SecretsManager::ResourcePolicy
    Properties:
      BlockPublicPolicy: true
      ResourcePolicy:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            AWS: !Ref 'AdminArn'
          Action:
          - secretsmanager:GetSecretValue
          - secretsmanager:PutSecretValue
          Resource: '*'
      SecretId: !Ref 'AdminSecret'
  ApartmentConfigTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Join [_, [APT_CONFIG, !GetAtt 'MakeAptIDCall.id']]
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
      - AttributeName: LOC
        AttributeType: S
      KeySchema:
      - AttributeName: LOC
        KeyType: HASH
      Tags:
      - Key: Product
        Value: Pure:CBS
  ResumeRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
      - PolicyName: ResumePolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - dynamodb:UpdateItem
            Resource:
            - !GetAtt 'MiscTable.Arn'
          - Effect: Allow
            Action:
            - ec2:DescribeInstances
            Resource: '*'
          - Effect: Allow
            Action:
            - ec2:StartInstances
            Resource:
            - !If [IsCreateCT0, !Join ['', [!Sub 'arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/',
                  !Ref 'PurityInstanceCT0']], !Ref 'AWS::NoValue']
            - !If [IsCreateCT1, !Join ['', [!Sub 'arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/',
                  !Ref 'PurityInstanceCT1']], !Ref 'AWS::NoValue']
  ResumeHandler:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'ResumeRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "import botocore\nfrom botocore.config import Config\nimport boto3\n\
          import logging\nimport os\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\
          \ndef check_and_set_resume(region, table_name):\n    \"\"\" Set Resume state\
          \ in DynamoDB only if the current state = suspending/resuming \"\"\"\n\n\
          \    try:\n        ddb_client = boto3.client('dynamodb', region_name=region,\n\
          \                                  config=Config(retries={'max_attempts':\
          \ 10}))\n        ddb_client.update_item(\n            TableName=table_name,\n\
          \            Key={\n                'PROPERTY_NAME': { 'S': 'suspend_resume_state'\
          \ },\n                },\n            UpdateExpression='SET PROPERTY_VALUE\
          \ = :new_state',\n            ConditionExpression='attribute_exists(PROPERTY_NAME)',\n\
          \            ExpressionAttributeValues={\n                ':new_state':\
          \ { 'S' : 'resuming' }\n                }\n            )\n        logger.info(\"\
          Set dynamodb state = resuming.\")\n    except botocore.exceptions.ClientError\
          \ as e:\n        if e.response['Error']['Code'] == 'ConditionalCheckFailedException':\n\
          \            raise Exception(\"Array has already resumed.\")\n        else:\n\
          \            logger.exception(e)\n            raise Exception(\"Could not\
          \ start resuming the array. Please contact Pure Storage Support.\")\n\n\
          def start_one_controller(region, ct0_id, ct1_id):\n    \"\"\" Start one\
          \ controller. \"\"\"\n\n    if not (ct0_id and ct1_id):\n        raise Exception(\"\
          Controller instance ID(s) missing.\")\n\n    try:\n        ec2 = boto3.resource('ec2',\
          \ region_name=region,\n                             config=Config(retries={'max_attempts':\
          \ 10}))\n        ct0 = ec2.Instance(ct0_id)\n        ct1 = ec2.Instance(ct1_id)\n\
          \n        if ct0.state['Name'] == 'running':\n            ct1.start()\n\
          \            ct1.wait_until_running()\n        else:\n            ct0.start()\n\
          \            ct0.wait_until_running()\n        logger.info(\"Started controller.\"\
          )\n    except Exception as e:\n        logger.exception(e)\n        if isinstance(e,\
          \ botocore.exceptions.ClientError) and e.response['Error']['Code'] in ['InstanceLimitExceeded',\
          \ 'InsufficientInstanceCapacity']:\n            raise Exception(\"Could\
          \ not start controller because of an AWS error: {} - {}\".format(e.response['Error']['Code'],\
          \ e.response['Error']['Message']))\n        else:\n            raise Exception(\"\
          Could not start controller instance. Please contact Pure Storage Support.\"\
          )\n\ndef handler(event, context):\n    \"\"\" Set Resume state in DynamoDB\
          \ and turn on one controller. \"\"\"\n    region = os.environ['Region']\n\
          \    ct0_id = os.environ['Controller0ID']\n    ct1_id = os.environ['Controller1ID']\n\
          \    table_name = os.environ['ResumeTableName']\n    try:\n        check_and_set_resume(region,\
          \ table_name)\n        start_one_controller(region, ct0_id, ct1_id)\n  \
          \  except Exception as e:\n        logger.error(\"Error occurred while starting\
          \ array resume: {}\".format(e))\n        status = 'Failed to resume array.\
          \ Error: {}'.format(e)\n    else:\n        status = 'Resume request received\
          \ for array.'\n\n    response = {\n        'Status' : status\n    }\n  \
          \  return response\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 900
      Environment:
        Variables:
          ResumeTableName: !Join [_, [MISC, !GetAtt 'MakeAptIDCall.id']]
          Controller0ID: !If [IsCreateCT0, !Ref 'PurityInstanceCT0', '']
          Controller1ID: !If [IsCreateCT1, !Ref 'PurityInstanceCT1', '']
          Region: !Ref 'AWS::Region'
  BucketCleanupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
      - PolicyName: deleteBucket
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - s3:*
            Resource:
            - !GetAtt 'ArrayBucket.Arn'
            - !Sub 'arn:${AWS::Partition}:s3:::${ArrayBucket}/*'
  BucketCleanupHandler:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'BucketCleanupRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "\"\"\"\nRemove all items from a bucket when a 'Delete' event is\
          \ received.\nThis is meant to be run from within an AWS::Lambda as a Custom\
          \ Resource.\n\"\"\"\n\nimport boto3\nimport json\nimport logging\nimport\
          \ cfnresponse\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\
          \nCREATE = \"Create\"\nUPDATE = \"Update\"\nDELETE = \"Delete\"\n\ndef on_create(event,\
          \ context):\n    props = event['ResourceProperties']\n    logger.info(\"\
          Bucket cleanup for {} ready\".format(props['BucketName']))\n\ndef on_delete(event,\
          \ context):\n    from datetime import datetime\n\n    props = event['ResourceProperties']\n\
          \    logger.info(\"Attempting to clear & delete bucket {}\".format(props['BucketName']))\n\
          \n    s3 = boto3.resource('s3', region_name=props['Region'])\n    try:\n\
          \        bucket = s3.Bucket(props['BucketName'])\n\n        logger.info(\"\
          Updating Lifecycle Configuration rules on bucket {}\".format(props['BucketName']))\n\
          \        bucket.LifecycleConfiguration().delete()\n        bucket.LifecycleConfiguration().put(\n\
          \            LifecycleConfiguration={'Rules': [{\n                'Filter':\
          \ {},\n                'Expiration': {'Date': datetime(2000, 1, 1)},\n \
          \               'Status': 'Enabled',\n                'NoncurrentVersionExpiration':\
          \ {'NoncurrentDays': 1}\n            },]})\n\n        return\n    except\
          \ s3.meta.client.exceptions.NoSuchBucket:\n        logger.info('Bucket {}\
          \ is gone'.format(props['BucketName']))\n        return\n    except Exception\
          \ as e:\n        logger.info('Error updating Lifecycle Configuration rules\
          \ on {}: {}'.format(props['BucketName'], e))\n        raise\n\ndef on_update(event,\
          \ context):\n    logger.info(\"Bucket Update is NO-OP\")\n\ndef handler(event,\
          \ context):\n\n    try:\n        logger.info(\"Received event: \" + json.dumps(event,\
          \ indent=2))\n\n        rtype = event[\"RequestType\"]\n        if rtype\
          \ == CREATE:\n            on_create(event, context)\n        elif rtype\
          \ == DELETE:\n            on_delete(event, context)\n        else:\n   \
          \         on_update(event, context)\n        cfnresponse.send(event, context,\
          \ cfnresponse.SUCCESS, {})\n    except Exception as e:\n        logger.error(\"\
          Error occurred while handling event: {}\".format(e))\n        cfnresponse.send(event,\
          \ context, cfnresponse.FAILED, {'Exception': str(e)})\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 900
  BucketCleanup:
    Type: Custom::BucketCleanupRunner
    DependsOn:
    - ArrayBucket
    Properties:
      ServiceToken: !GetAtt 'BucketCleanupHandler.Arn'
      BucketName: !Join ['-', [pure, !GetAtt 'MakeAptIDCall.id']]
      Region: !Ref 'AWS::Region'
      Tags:
      - Key: Product
        Value: Pure:CBS
  VolumeAttachmentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
      - PolicyName: tieVolumesToInstances
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - ec2:DescribeInstances
            - ec2:ModifyInstanceAttribute
            Resource: '*'
  VolumeAttachmentHandler:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'VolumeAttachmentRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "\"\"\"\nSet DeleteOnTermination to true for all NVRAM EBS volumes\
          \ to ensure deletion.\nThis is meant to be run from within an AWS::Lambda\
          \ as a Custom Resource.\n\"\"\"\n\nimport boto3\nimport json\nimport logging\n\
          import cfnresponse\n\nfrom botocore.config import Config\n\nlogger = logging.getLogger()\n\
          logger.setLevel(logging.INFO)\n\nCREATE = \"Create\"\nUPDATE = \"Update\"\
          \nDELETE = \"Delete\"\n\ndef on_create(event, context):\n    props = event['ResourceProperties']\n\
          \    logger.info(\"VolumeAttachmentHandler for {} ready\".format(props['ArrayId']))\n\
          \ndef on_update(event, context):\n    logger.info(\"VolumeAttachmentHandler\
          \ Update is NO-OP\")\n\ndef on_delete(event, context):\n    props = event['ResourceProperties']\n\
          \    logger.info(\"Modifying all {} instances to delete attached volumes\"\
          .format(props['ArrayId']))\n\n    ec2_client = boto3.client('ec2',\n   \
          \                           region_name=props['Region'],\n             \
          \                 config=Config(retries={'max_attempts': 10}))\n    response\
          \ = ec2_client.describe_instances(Filters=[{\n        'Name': 'tag:PS_ARRAY_ID',\n\
          \        'Values': [props['ArrayId']]}])\n    for reservation in response.get('Reservations',\
          \ []):\n        for instance in reservation.get('Instances', []):\n    \
          \        logger.info(\"Instance {} has {} attached volumes\".format(\n \
          \                       instance['InstanceId'], len(instance.get('BlockDeviceMappings',\
          \ []))))\n            for volume in instance.get('BlockDeviceMappings',\
          \ []):\n                if not volume.get('Ebs', {}).get('DeleteOnTermination',\
          \ True):\n                    logger.info(\"Setting {} attachment {} ({})\
          \ to delete on instance termination\".format(\n                        \
          \        instance['InstanceId'], volume['DeviceName'], volume['Ebs']['VolumeId']))\n\
          \                    ec2_client.modify_instance_attribute(\n           \
          \             InstanceId=instance['InstanceId'],\n                     \
          \   BlockDeviceMappings=[{\n                            'DeviceName': volume['DeviceName'],\n\
          \                            'Ebs': {'DeleteOnTermination': True}}])\n\n\
          def handler(event, context):\n\n    try:\n        logger.info(\"Received\
          \ event: \" + json.dumps(event, indent=2))\n\n        rtype = event[\"RequestType\"\
          ]\n        if rtype == CREATE:\n            on_create(event, context)\n\
          \        elif rtype == DELETE:\n            on_delete(event, context)\n\
          \        else:\n            on_update(event, context)\n        cfnresponse.send(event,\
          \ context, cfnresponse.SUCCESS, {})\n    except Exception as e:\n      \
          \  logger.error(\"Error occurred while handling event: {}\".format(e))\n\
          \        cfnresponse.send(event, context, cfnresponse.FAILED, {'Exception':\
          \ str(e)})\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 60
  VolumeAttachment:
    Type: Custom::VolumeAttachmentRunner
    DependsOn:
    - VDGroup0
    Properties:
      ServiceToken: !GetAtt 'VolumeAttachmentHandler.Arn'
      ArrayId: !GetAtt 'MakeArrayIDCall.id'
      Region: !Ref 'AWS::Region'
      Tags:
      - Key: Product
        Value: Pure:CBS
  ControllerCleanupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      ManagedPolicyArns:
      - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
      - PolicyName: changeControllerAttribute
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - ec2:ModifyInstanceAttribute
            Resource: '*'
  ControllerCleanupHandler:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt 'ControllerCleanupRole.Arn'
      Handler: index.handler
      Code:
        ZipFile: "\"\"\"\nRemove DisableApiTermination from a controller when a 'Delete'\
          \ event is received.\nAdd DisableApiTermination to a controller when a 'Create'\
          \ event is received, to\nensure it can be deleted in case of stack creation\
          \ failure.\nThis is meant to be run from within an AWS::Lambda as a Custom\
          \ Resource.\n\"\"\"\n\nimport boto3\nimport cfnresponse\nimport json\nimport\
          \ logging\n\nlogger = logging.getLogger()\nlogger.setLevel(logging.INFO)\n\
          \nCREATE = \"Create\"\nUPDATE = \"Update\"\nDELETE = \"Delete\"\n\ndef setDisableApiTermination(controller_id,\
          \ region, value):\n    logger.info(\"Attempting to set DisableApiTermination\
          \ = {} on controller {}\".format(value, controller_id))\n\n    ec2 = boto3.resource('ec2',\
          \ region_name=region)\n\n    controller = ec2.Instance(controller_id)\n\
          \    controller.modify_attribute(DisableApiTermination={'Value': value})\n\
          \ndef on_create(event, context):\n    props = event['ResourceProperties']\n\
          \    logger.info(\"Controller cleanup for {} ready\".format(props['ControllerID']))\n\
          \    setDisableApiTermination(props['ControllerID'], props['Region'], True)\n\
          \ndef on_delete(event, context):\n    props = event['ResourceProperties']\n\
          \    setDisableApiTermination(props['ControllerID'], props['Region'], False)\n\
          \ndef on_update(event, context):\n    logger.info(\"Controller Update is\
          \ NO-OP\")\n\ndef handler(event, context):\n\n    try:\n        logger.info(\"\
          Received event: \" + json.dumps(event, indent=2))\n\n        rtype = event[\"\
          RequestType\"]\n        if rtype == CREATE:\n            on_create(event,\
          \ context)\n        elif rtype == DELETE:\n            on_delete(event,\
          \ context)\n        else:\n            on_update(event, context)\n     \
          \   cfnresponse.send(event, context, cfnresponse.SUCCESS, {})\n    except\
          \ Exception as e:\n        logger.error(\"Error occurred while handling\
          \ event: {}\".format(e))\n        cfnresponse.send(event, context, cfnresponse.FAILED,\
          \ {'Exception': str(e)})\n"
      Runtime: python3.6
      Tags:
      - Key: Product
        Value: Pure:CBS
      Timeout: 900
  Controller0Cleanup:
    Condition: IsCreateCT0
    DependsOn:
    - PurityInstanceCT0
    Type: Custom::ControllerCleanupRunner
    Properties:
      ServiceToken: !GetAtt 'ControllerCleanupHandler.Arn'
      ControllerID: !Ref 'PurityInstanceCT0'
      Region: !Ref 'AWS::Region'
      Tags:
      - Key: Product
        Value: Pure:CBS
  Controller1Cleanup:
    Condition: IsCreateCT1
    DependsOn:
    - PurityInstanceCT1
    Type: Custom::ControllerCleanupRunner
    Properties:
      ServiceToken: !GetAtt 'ControllerCleanupHandler.Arn'
      ControllerID: !Ref 'PurityInstanceCT1'
      Region: !Ref 'AWS::Region'
      Tags:
      - Key: Product
        Value: Pure:CBS
  AULiveSetTable:
    Condition: IsUsingAULiveSetTable
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Join [_, [AU_LIVE_SET, !GetAtt 'MakeAptIDCall.id']]
      BillingMode: PROVISIONED
      ProvisionedThroughput:
        WriteCapacityUnits: !If [IsCustomAULiveSetTableMinWCU, !Ref 'AULiveSetTableMinWCU',
          !FindInMap [!Ref 'PurityInstanceType', AULiveSetTable, MinWCU]]
        ReadCapacityUnits: !If [IsCustomAULiveSetTableMinRCU, !Ref 'AULiveSetTableMinRCU',
          !FindInMap [!Ref 'PurityInstanceType', AULiveSetTable, MinRCU]]
      AttributeDefinitions:
      - AttributeName: AU_ADDR
        AttributeType: S
      KeySchema:
      - AttributeName: AU_ADDR
        KeyType: HASH
      Tags:
      - Key: Product
        Value: Pure:CBS
  AULiveSetTableWriteCapacityScalableTarget:
    Condition: IsUsingAULiveSetTable
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MaxCapacity: !FindInMap [!Ref 'PurityInstanceType', AULiveSetTable, MaxWCU]
      MinCapacity: !FindInMap [!Ref 'PurityInstanceType', AULiveSetTable, DisabledCapacityUnits]
      ResourceId: !Sub 'table/${AULiveSetTable}'
      RoleARN: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsservicerole/dynamodb.applicationautoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_DynamoDBTable'
      ScalableDimension: dynamodb:table:WriteCapacityUnits
      ServiceNamespace: dynamodb
    DependsOn: AULiveSetTable
  AULiveSetTableWriteScalingPolicy:
    Condition: IsUsingAULiveSetTable
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: WriteAutoScalingPolicy
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref 'AULiveSetTableWriteCapacityScalableTarget'
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 70
        ScaleInCooldown: 60
        ScaleOutCooldown: 0
        PredefinedMetricSpecification:
          PredefinedMetricType: DynamoDBWriteCapacityUtilization
  AULiveSetTableReadCapacityScalableTarget:
    Condition: IsUsingAULiveSetTable
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Properties:
      MaxCapacity: !FindInMap [!Ref 'PurityInstanceType', AULiveSetTable, MaxWCU]
      MinCapacity: !FindInMap [!Ref 'PurityInstanceType', AULiveSetTable, DisabledCapacityUnits]
      ResourceId: !Sub 'table/${AULiveSetTable}'
      RoleARN: !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsservicerole/dynamodb.applicationautoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_DynamoDBTable'
      ScalableDimension: dynamodb:table:ReadCapacityUnits
      ServiceNamespace: dynamodb
    DependsOn: AULiveSetTable
  AULiveSetTableReadScalingPolicy:
    Condition: IsUsingAULiveSetTable
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Properties:
      PolicyName: ReadAutoScalingPolicy
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref 'AULiveSetTableReadCapacityScalableTarget'
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: 70
        ScaleInCooldown: 60
        ScaleOutCooldown: 0
        PredefinedMetricSpecification:
          PredefinedMetricType: DynamoDBReadCapacityUtilization
  HAConfigTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Join [_, [HA_CONFIG, !GetAtt 'MakeAptIDCall.id']]
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
      - AttributeName: VIRTUAL_SLOT_ID
        AttributeType: S
      KeySchema:
      - AttributeName: VIRTUAL_SLOT_ID
        KeyType: HASH
      Tags:
      - Key: Product
        Value: Pure:CBS
  TunablesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Join [_, [TUNABLES, !GetAtt 'MakeAptIDCall.id']]
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
      - AttributeName: DEVICE_TYPE
        AttributeType: S
      - AttributeName: TUNABLE_NAME
        AttributeType: S
      KeySchema:
      - AttributeName: DEVICE_TYPE
        KeyType: HASH
      - AttributeName: TUNABLE_NAME
        KeyType: RANGE
      Tags:
      - Key: Product
        Value: Pure:CBS
  MiscTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Join [_, [MISC, !GetAtt 'MakeAptIDCall.id']]
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
      - AttributeName: PROPERTY_NAME
        AttributeType: S
      KeySchema:
      - AttributeName: PROPERTY_NAME
        KeyType: HASH
      Tags:
      - Key: Product
        Value: Pure:CBS
  PurityInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
          Action:
          - sts:AssumeRole
  PuritySupportingInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
          Action:
          - sts:AssumeRole
  PuritySharedInstancePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: purity_shared_instance_policy
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action: autoscaling:CompleteLifecycleAction
          Resource: !Sub 'arn:${AWS::Partition}:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AWS::StackName}-VDGroup*-*'
        - Effect: Allow
          Action:
          - autoscaling:DescribeAutoScalingGroups
          - autoscaling:DescribeAutoScalingInstances
          Resource: '*'
        - Effect: Allow
          Action:
          - cloudformation:DescribeStacks
          Resource: !Ref 'AWS::StackId'
        - Effect: Allow
          Action:
          - dynamodb:BatchGetItem
          - dynamodb:BatchWriteItem
          - dynamodb:DeleteItem
          - dynamodb:DescribeTable
          - dynamodb:GetItem
          - dynamodb:PutItem
          - dynamodb:Query
          - dynamodb:Scan
          - dynamodb:UpdateItem
          - dynamodb:UpdateTable
          Resource:
          - !GetAtt 'ApartmentConfigTable.Arn'
          - !GetAtt 'HAConfigTable.Arn'
          - !GetAtt 'TunablesTable.Arn'
          - !GetAtt 'MiscTable.Arn'
          - !If [IsUsingAULiveSetTable, !GetAtt 'AULiveSetTable.Arn', !Ref 'AWS::NoValue']
        - Effect: Allow
          Action:
          - ec2:DescribeInstances
          - ec2:DescribeNetworkInterfaces
          - ec2:DescribeSubnets
          - ec2:DescribeTags
          - ec2:DescribeVolumes
          Resource: '*'
        - Effect: Allow
          Action: ec2:ModifyInstanceMetadataOptions
          Resource: !Sub 'arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:instance/*'
        - Effect: Allow
          Action:
          - ec2:CreateTags
          Resource: !Sub 'arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:volume/*'
        - Effect: Allow
          Action:
          - ec2:CreateTags
          - ec2:DeleteTags
          Resource: '*'
          Condition:
            StringEquals:
              aws:ResourceTag/aws:cloudformation:stack-id: !Ref 'AWS::StackId'
        - Effect: Allow
          Action:
          - ec2:CreateTags
          - ec2:DeleteTags
          Resource: '*'
          Condition:
            StringEquals:
              aws:ResourceTag/pure:cbs:stack-id: !Ref 'AWS::StackId'
        - Effect: Allow
          Action:
          - s3:ListBucket
          - s3:ListBucketVersions
          Resource: !GetAtt 'ArrayBucket.Arn'
        - Effect: Allow
          Action:
          - s3:DeleteObject
          - s3:DeleteObjectVersion
          - s3:GetObject
          - s3:PutObject
          Resource: !Join [/, [!GetAtt 'ArrayBucket.Arn', '*']]
      Roles:
      - !Ref 'PurityInstanceRole'
      - !Ref 'PuritySupportingInstanceRole'
  PurityControllerInstancePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: purity_controller_instance_policy
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action:
          - kms:CancelKeyDeletion
          - kms:Create*
          - kms:Decrypt
          - kms:Delete*
          - kms:Describe*
          - kms:DescribeKey
          - kms:Disable*
          - kms:Enable*
          - kms:Encrypt
          - kms:Get*
          - kms:List*
          - kms:Put*
          - kms:ReEncrypt*
          - kms:Revoke*
          - kms:ScheduleKeyDeletion
          - kms:Update*
          Resource: !Sub 'arn:${AWS::Partition}:kms:${AWS::Region}:${AWS::AccountId}:key/${PureDataSecurityKey}'
        - Effect: Allow
          Action:
          - kms:GenerateRandom
          Resource: '*'
        - Effect: Allow
          Action:
          - cloudformation:CreateChangeSet
          - cloudformation:DeleteStack
          - cloudformation:ExecuteChangeSet
          - cloudformation:GetTemplate
          - cloudformation:GetTemplateSummary
          - cloudformation:ListStackInstances
          - cloudformation:ListStackResources
          Resource: !Ref 'AWS::StackId'
        - Effect: Allow
          Action:
          - autoscaling:ResumeProcesses
          - autoscaling:SetInstanceHealth
          - autoscaling:SuspendProcesses
          - autoscaling:TerminateInstanceInAutoScalingGroup
          - autoscaling:UpdateAutoScalingGroup
          Resource: !Sub 'arn:${AWS::Partition}:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/${AWS::StackName}-VDGroup*-*'
        - Effect: Allow
          Action:
          - ec2:RebootInstances
          - ec2:StartInstances
          - ec2:StopInstances
          Resource: '*'
          Condition:
            StringEquals:
              aws:ResourceTag/aws:cloudformation:stack-id: !Ref 'AWS::StackId'
        - Effect: Allow
          Action:
          - autoscaling:DescribeAutoScalingGroups
          - autoscaling:DescribeAutoScalingInstances
          - autoscaling:DescribeLaunchConfigurations
          - autoscaling:DescribeScalingActivities
          - autoscaling:DescribeScalingProcessTypes
          - cloudformation:DescribeChangeSet
          - cloudformation:DescribeStackEvents
          - cloudformation:DescribeStackInstance
          - cloudformation:DescribeStackResource
          - cloudformation:DescribeStackResources
          - cloudformation:DescribeStacks
          - ec2:AssignPrivateIpAddresses
          - ec2:DeleteVolume
          - ec2:DescribeImages
          - ec2:DescribeInstanceStatus
          - ec2:ModifyInstanceAttribute
          - ec2:DescribeLaunchTemplateVersions
          - iam:SimulatePrincipalPolicy
          Resource: '*'
        - Effect: Allow
          Action:
          - ec2:DescribeVpcEndpoints
          Resource: '*'
      Roles:
      - !Ref 'PurityInstanceRole'
  PurityInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
      - !Ref 'PurityInstanceRole'
  PuritySupportingInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
      - !Ref 'PuritySupportingInstanceRole'
  VDPlacementGroup0:
    Type: AWS::EC2::PlacementGroup
    Properties:
      Strategy: spread
  VDPlacementGroup1:
    Type: AWS::EC2::PlacementGroup
    Condition: IsCreateVDGroup1
    Properties:
      Strategy: spread
  VDPlacementGroup2:
    Type: AWS::EC2::PlacementGroup
    Condition: IsCreateVDGroup2
    Properties:
      Strategy: spread
  VDPlacementGroup3:
    Type: AWS::EC2::PlacementGroup
    Condition: IsCreateVDGroup3
    Properties:
      Strategy: spread
  CTPlacementGroup:
    Type: AWS::EC2::PlacementGroup
    Properties:
      Strategy: !If [IsDedicatedInstance, partition, spread]
  SystemInterfaceCT0:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT0
    Properties:
      Description: System network interface CT0
      SubnetId: !Ref 'SystemSubnet'
      GroupSet:
      - !Ref 'PureSystemSecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  ManagementInterfaceCT0:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT0
    Properties:
      Description: Management Interface CT0
      SubnetId: !Ref 'ManagementSubnet'
      SecondaryPrivateIpAddressCount: !If [IsInitialDeploymentCT0, 1, !Ref 'AWS::NoValue']
      GroupSet:
      - !Ref 'ManagementSecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  iSCSIInterfaceCT0:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT0
    Properties:
      Description: iSCSI Interface CT0
      SubnetId: !If [IsCustomISCSISubnetCT0, !Ref 'ISCSISubnetCT0', !Ref 'ISCSISubnet']
      SecondaryPrivateIpAddressCount: !If [IsCustomISCSIAddressCT0, !Ref 'AWS::NoValue',
        1]
      GroupSet:
      - !Ref 'ISCSISecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  ReplicationInterfaceCT0:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT0
    Properties:
      Description: Replication Interface CT0
      SubnetId: !If [IsCustomReplicationSubnetCT0, !Ref 'ReplicationSubnetCT0', !Ref 'ReplicationSubnet']
      SecondaryPrivateIpAddressCount: !If [IsCustomReplicationAddressCT0, !Ref 'AWS::NoValue',
        1]
      GroupSet:
      - !Ref 'ReplicationSecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  SystemInterfaceCT1:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT1
    Properties:
      Description: System network interface CT1
      SubnetId: !Ref 'SystemSubnet'
      GroupSet:
      - !Ref 'PureSystemSecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  ManagementInterfaceCT1:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT1
    Properties:
      Description: Management Interface CT1
      SubnetId: !Ref 'ManagementSubnet'
      GroupSet:
      - !Ref 'ManagementSecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  iSCSIInterfaceCT1:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT1
    Properties:
      Description: iSCSI Interface CT1
      SubnetId: !If [IsCustomISCSISubnetCT1, !Ref 'ISCSISubnetCT1', !Ref 'ISCSISubnet']
      SecondaryPrivateIpAddressCount: !If [IsCustomISCSIAddressCT1, !Ref 'AWS::NoValue',
        1]
      GroupSet:
      - !Ref 'ISCSISecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  ReplicationInterfaceCT1:
    Type: AWS::EC2::NetworkInterface
    Condition: IsCreateCT1
    Properties:
      Description: Replication Interface CT1
      SubnetId: !If [IsCustomReplicationSubnetCT1, !Ref 'ReplicationSubnetCT1', !Ref 'ReplicationSubnet']
      SecondaryPrivateIpAddressCount: !If [IsCustomReplicationAddressCT1, !Ref 'AWS::NoValue',
        1]
      GroupSet:
      - !Ref 'ReplicationSecurityGroup'
      Tags:
      - Key: Product
        Value: Pure:CBS
  VDLaunchTemplate0:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateData:
        ImageId: !FindInMap [AWSRegion2AMI, !Ref 'AWS::Region', Value]
        InstanceType: !If [IsVDi3enFamily, !FindInMap [!Ref 'PurityInstanceType',
            vd-instance, i3en], !FindInMap [!Ref 'PurityInstanceType', vd-instance,
            i3]]
        BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            KmsKeyId: !If [IsEncryptWithDefaultKey, !Ref 'AWS::NoValue', alias/aws/ebs]
            VolumeSize: 100
            VolumeType: gp2
        - DeviceName: /dev/sdf
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            Iops: !If [IsCustomNVRAMIOPs, !Ref 'CustomNVRAMIOPs', !FindInMap [!Ref 'PurityInstanceType',
                nvram, iops]]
            KmsKeyId: !If [IsEncryptWithDefaultKey, !Ref 'AWS::NoValue', alias/aws/ebs]
            VolumeSize: !FindInMap [!Ref 'PurityInstanceType', !FindInMap [AWSRegion2HW,
                !Ref 'AWS::Region', nvramtype], nvramsize]
            VolumeType: !If [IsCustomNVRAMVolumeType, !Ref 'CustomNVRAMVolumeType',
              !FindInMap [!Ref 'PurityInstanceType', !FindInMap [AWSRegion2HW, !Ref 'AWS::Region',
                  nvramtype], nvramtype]]
        IamInstanceProfile:
          Arn: !GetAtt 'PuritySupportingInstanceProfile.Arn'
        KeyName: !Ref 'KeyName'
        SecurityGroupIds:
        - !Ref 'PureSystemSecurityGroup'
        MetadataOptions:
          HttpEndpoint: enabled
          HttpTokens: required
        TagSpecifications:
        - ResourceType: volume
          Tags:
          - Key: Product
            Value: Pure:CBS
          - Key: pure:cbs:stack-id
            Value: !Ref 'AWS::StackId'
  VDGroup0:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref 'VDLaunchTemplate0'
        Version: !GetAtt 'VDLaunchTemplate0.LatestVersionNumber'
      MaxSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      MinSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      VPCZoneIdentifier:
      - !Ref 'SystemSubnet'
      PlacementGroup: !Ref 'VDPlacementGroup0'
      LifecycleHookSpecificationList:
      - LifecycleTransition: autoscaling:EC2_INSTANCE_LAUNCHING
        LifecycleHookName: vdLaunchingLifecycleHook
        HeartbeatTimeout: 900
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'ArrayName', vd]]
        PropagateAtLaunch: true
      - Key: PS_CLOUD_ROLE
        Value: vd
        PropagateAtLaunch: true
      - Key: PS_CLOUD_APT_ID
        Value: !GetAtt 'MakeAptIDCall.id'
        PropagateAtLaunch: true
      - Key: PS_ARRAY_ID
        Value: !GetAtt 'MakeArrayIDCall.id'
        PropagateAtLaunch: true
      - Key: Product
        Value: Pure:CBS
        PropagateAtLaunch: true
    DependsOn:
    - SecurityGroupCheckupCall
    - SubnetCheckupCall
    - BucketCleanup
    - PuritySharedInstancePolicy
  VDLaunchTemplate1:
    Type: AWS::EC2::LaunchTemplate
    Condition: IsCreateVDGroup1
    Properties:
      LaunchTemplateData:
        ImageId: !FindInMap [AWSRegion2AMI, !Ref 'AWS::Region', Value]
        InstanceType: !If [IsVDi3enFamily, i3en.xlarge, i3.2xlarge]
        BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            KmsKeyId: !If [IsEncryptWithDefaultKey, !Ref 'AWS::NoValue', alias/aws/ebs]
            VolumeSize: 100
            VolumeType: gp2
        IamInstanceProfile:
          Arn: !GetAtt 'PuritySupportingInstanceProfile.Arn'
        KeyName: !Ref 'KeyName'
        SecurityGroupIds:
        - !Ref 'PureSystemSecurityGroup'
        MetadataOptions:
          HttpEndpoint: enabled
          HttpTokens: required
        TagSpecifications:
        - ResourceType: volume
          Tags:
          - Key: Product
            Value: Pure:CBS
          - Key: pure:cbs:stack-id
            Value: !Ref 'AWS::StackId'
  VDGroup1:
    Type: AWS::AutoScaling::AutoScalingGroup
    Condition: IsCreateVDGroup1
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref 'VDLaunchTemplate1'
        Version: !GetAtt 'VDLaunchTemplate1.LatestVersionNumber'
      MaxSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      MinSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      VPCZoneIdentifier:
      - !Ref 'SystemSubnet'
      PlacementGroup: !Ref 'VDPlacementGroup1'
      LifecycleHookSpecificationList:
      - LifecycleTransition: autoscaling:EC2_INSTANCE_LAUNCHING
        LifecycleHookName: vdLaunchingLifecycleHook
        HeartbeatTimeout: 900
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'ArrayName', vd]]
        PropagateAtLaunch: true
      - Key: PS_CLOUD_ROLE
        Value: vd
        PropagateAtLaunch: true
      - Key: PS_CLOUD_APT_ID
        Value: !GetAtt 'MakeAptIDCall.id'
        PropagateAtLaunch: true
      - Key: PS_ARRAY_ID
        Value: !GetAtt 'MakeArrayIDCall.id'
        PropagateAtLaunch: true
      - Key: Product
        Value: Pure:CBS
        PropagateAtLaunch: true
  VDLaunchTemplate2:
    Type: AWS::EC2::LaunchTemplate
    Condition: IsCreateVDGroup2
    Properties:
      LaunchTemplateData:
        ImageId: !FindInMap [AWSRegion2AMI, !Ref 'AWS::Region', Value]
        InstanceType: !If [IsVDi3enFamily, i3en.3xlarge, i3.4xlarge]
        BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            KmsKeyId: !If [IsEncryptWithDefaultKey, !Ref 'AWS::NoValue', alias/aws/ebs]
            VolumeSize: 100
            VolumeType: gp2
        IamInstanceProfile:
          Arn: !GetAtt 'PuritySupportingInstanceProfile.Arn'
        KeyName: !Ref 'KeyName'
        SecurityGroupIds:
        - !Ref 'PureSystemSecurityGroup'
        MetadataOptions:
          HttpEndpoint: enabled
          HttpTokens: required
        TagSpecifications:
        - ResourceType: volume
          Tags:
          - Key: Product
            Value: Pure:CBS
          - Key: pure:cbs:stack-id
            Value: !Ref 'AWS::StackId'
  VDGroup2:
    Type: AWS::AutoScaling::AutoScalingGroup
    Condition: IsCreateVDGroup2
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref 'VDLaunchTemplate2'
        Version: !GetAtt 'VDLaunchTemplate2.LatestVersionNumber'
      MaxSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      MinSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      VPCZoneIdentifier:
      - !Ref 'SystemSubnet'
      PlacementGroup: !Ref 'VDPlacementGroup2'
      LifecycleHookSpecificationList:
      - LifecycleTransition: autoscaling:EC2_INSTANCE_LAUNCHING
        LifecycleHookName: vdLaunchingLifecycleHook
        HeartbeatTimeout: 900
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'ArrayName', vd]]
        PropagateAtLaunch: true
      - Key: PS_CLOUD_ROLE
        Value: vd
        PropagateAtLaunch: true
      - Key: PS_CLOUD_APT_ID
        Value: !GetAtt 'MakeAptIDCall.id'
        PropagateAtLaunch: true
      - Key: PS_ARRAY_ID
        Value: !GetAtt 'MakeArrayIDCall.id'
        PropagateAtLaunch: true
      - Key: Product
        Value: Pure:CBS
        PropagateAtLaunch: true
  VDLaunchTemplate3:
    Type: AWS::EC2::LaunchTemplate
    Condition: IsCreateVDGroup3
    Properties:
      LaunchTemplateData:
        ImageId: !FindInMap [AWSRegion2AMI, !Ref 'AWS::Region', Value]
        InstanceType: !If [IsVDi3enFamily, i3en.3xlarge, i3.8xlarge]
        BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            KmsKeyId: !If [IsEncryptWithDefaultKey, !Ref 'AWS::NoValue', alias/aws/ebs]
            VolumeSize: 100
            VolumeType: gp2
        IamInstanceProfile:
          Arn: !GetAtt 'PuritySupportingInstanceProfile.Arn'
        KeyName: !Ref 'KeyName'
        SecurityGroupIds:
        - !Ref 'PureSystemSecurityGroup'
        MetadataOptions:
          HttpEndpoint: enabled
          HttpTokens: required
        TagSpecifications:
        - ResourceType: volume
          Tags:
          - Key: Product
            Value: Pure:CBS
          - Key: pure:cbs:stack-id
            Value: !Ref 'AWS::StackId'
  VDGroup3:
    Type: AWS::AutoScaling::AutoScalingGroup
    Condition: IsCreateVDGroup3
    Properties:
      LaunchTemplate:
        LaunchTemplateId: !Ref 'VDLaunchTemplate3'
        Version: !GetAtt 'VDLaunchTemplate3.LatestVersionNumber'
      MaxSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      MinSize: !FindInMap [!Ref 'PurityInstanceType', num-vds, count]
      VPCZoneIdentifier:
      - !Ref 'SystemSubnet'
      PlacementGroup: !Ref 'VDPlacementGroup3'
      LifecycleHookSpecificationList:
      - LifecycleTransition: autoscaling:EC2_INSTANCE_LAUNCHING
        LifecycleHookName: vdLaunchingLifecycleHook
        HeartbeatTimeout: 900
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'ArrayName', vd]]
        PropagateAtLaunch: true
      - Key: PS_CLOUD_ROLE
        Value: vd
        PropagateAtLaunch: true
      - Key: PS_CLOUD_APT_ID
        Value: !GetAtt 'MakeAptIDCall.id'
        PropagateAtLaunch: true
      - Key: PS_ARRAY_ID
        Value: !GetAtt 'MakeArrayIDCall.id'
        PropagateAtLaunch: true
      - Key: Product
        Value: Pure:CBS
        PropagateAtLaunch: true
  PurityInstanceCT0:
    Type: AWS::EC2::Instance
    Condition: IsCreateCT0
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'ArrayName', ct0]]
      - Key: PS_ARRAY_ID
        Value: !GetAtt 'MakeArrayIDCall.id'
      - Key: PS_CLOUD_ROLE
        Value: ct
      - Key: PS_CLOUD_ROLE_ID
        Value: 0
      - Key: PS_CLOUD_APT_ID
        Value: !GetAtt 'MakeAptIDCall.id'
      - Key: Product
        Value: Pure:CBS
      - Key: ProductVersion
        Value: 202110200459+eefec2eede9e-62x
      AvailabilityZone: !GetAtt 'VPCInfoCall.az'
      Tenancy: !If [IsDedicatedInstance, !Ref 'InstanceTenancy', !Ref 'AWS::NoValue']
      ImageId: !If [IsCustomCT0AMI, !Ref 'CustomCT0AMI', !FindInMap [AWSRegion2AMI,
          !Ref 'AWS::Region', Value]]
      InstanceType: !If [IsCustomCT0InstanceType, !Ref 'CustomCT0InstanceType', !FindInMap [
          !Ref 'PurityInstanceType', controller-instance, type]]
      KeyName: !Ref 'KeyName'
      IamInstanceProfile: !Ref 'PurityInstanceProfile'
      PlacementGroupName: !Ref 'CTPlacementGroup'
      NetworkInterfaces:
      - NetworkInterfaceId: !Ref 'SystemInterfaceCT0'
        DeviceIndex: 0
      - NetworkInterfaceId: !Ref 'ReplicationInterfaceCT0'
        DeviceIndex: 1
      - NetworkInterfaceId: !Ref 'iSCSIInterfaceCT0'
        DeviceIndex: 2
      - NetworkInterfaceId: !Ref 'ManagementInterfaceCT0'
        DeviceIndex: 3
      UserData: !Base64
        Fn::Join:
        - ''
        - - '#!/bin/bash -xe

            '
          - DO_INIT=1
          - '

            '
          - DATA_SECURITY_CMK=
          - !If [IsInitialDeploymentCT0, !Ref 'PureDataSecurityKey', '']
          - '

            '
          - CFN_PURITY_LOGICAL_ID=PurityInstanceCT0
          - '

            '
          - CFN_REGION=
          - !Ref 'AWS::Region'
          - '

            '
          - ARRAY_NAME=
          - !If [IsInitialDeploymentCT0, !Ref 'ArrayName', '']
          - '

            '
          - LOG_SENDER_DOMAIN=
          - !If [IsInitialDeploymentCT0, !Ref 'LogSenderDomain', '']
          - '

            '
          - ALERT_RECIPIENTS=
          - !If [IsInitialDeploymentCT0, !Join [',', !Ref 'AlertRecipients'], '']
          - '

            '
          - VDGROUP=
          - !If [IsInitialDeploymentCT0, !Ref 'VDPlacementGroup0', '']
          - '

            '
          - NUM_VDS=
          - !If [IsInitialDeploymentCT0, !FindInMap [!Ref 'PurityInstanceType', num-vds,
              count], '']
          - '

            '
          - PS_LICENSE_KEY=
          - !Ref 'LicenseKey'
          - '

            '
          - IS_REPLACEMENT_CONTROLLER=
          - !If [IsInitialDeploymentCT0, '', 1]
          - '

            '
          - ACTIVATION_SIGNAL_URL=
          - '"'
          - !If [IsInitialDeploymentCT0, !Ref 'LicenseActivationWaitHandle', '']
          - '"'
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT20M
    DependsOn:
    - VDGroup0
    - BucketCleanup
    - VolumeAttachment
    - PuritySharedInstancePolicy
    - PurityControllerInstancePolicy
  LicenseActivationWaitHandle:
    Condition: IsInitialDeploymentCT0
    Type: AWS::CloudFormation::WaitConditionHandle
  LicenseActivationWait:
    Condition: IsInitialDeploymentCT0
    Type: AWS::CloudFormation::WaitCondition
    Properties:
      Handle: !Ref 'LicenseActivationWaitHandle'
      Timeout: 1800
    DependsOn:
    - VDGroup0
  PurityInstanceCT1:
    Type: AWS::EC2::Instance
    Condition: IsCreateCT1
    DependsOn:
    - BucketCleanup
    - VolumeAttachment
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'ArrayName', ct1]]
      - Key: PS_ARRAY_ID
        Value: !GetAtt 'MakeArrayIDCall.id'
      - Key: PS_CLOUD_ROLE
        Value: ct
      - Key: PS_CLOUD_ROLE_ID
        Value: 1
      - Key: PS_CLOUD_APT_ID
        Value: !GetAtt 'MakeAptIDCall.id'
      - Key: Peer
        Value: !If [IsCreateCT0, !Ref 'PurityInstanceCT0', '']
      - Key: Product
        Value: Pure:CBS
      AvailabilityZone: !GetAtt 'VPCInfoCall.az'
      Tenancy: !If [IsDedicatedInstance, !Ref 'InstanceTenancy', !Ref 'AWS::NoValue']
      ImageId: !If [IsCustomCT1AMI, !Ref 'CustomCT1AMI', !FindInMap [AWSRegion2AMI,
          !Ref 'AWS::Region', Value]]
      InstanceType: !If [IsCustomCT1InstanceType, !Ref 'CustomCT1InstanceType', !FindInMap [
          !Ref 'PurityInstanceType', controller-instance, type]]
      KeyName: !Ref 'KeyName'
      IamInstanceProfile: !Ref 'PurityInstanceProfile'
      PlacementGroupName: !Ref 'CTPlacementGroup'
      NetworkInterfaces:
      - NetworkInterfaceId: !Ref 'SystemInterfaceCT1'
        DeviceIndex: 0
      - NetworkInterfaceId: !Ref 'ReplicationInterfaceCT1'
        DeviceIndex: 1
      - NetworkInterfaceId: !Ref 'iSCSIInterfaceCT1'
        DeviceIndex: 2
      - NetworkInterfaceId: !Ref 'ManagementInterfaceCT1'
        DeviceIndex: 3
      UserData: !Base64
        Fn::Join:
        - ''
        - - '#!/bin/bash -xe

            '
          - DO_INIT=1
          - '

            '
          - CFN_PURITY_LOGICAL_ID=PurityInstanceCT1
          - '

            '
          - CFN_REGION=
          - !Ref 'AWS::Region'
          - '

            '
          - IS_REPLACEMENT_CONTROLLER=
          - !If [IsInitialDeploymentCT1, '', 1]
          - '

            '
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT10M
Outputs:
  AdminSecretsManagerArn:
    Condition: IsAdminArn
    Description: Administration credentials used by CBS terraform provider.
    Value: !Ref 'AdminSecret'
  PurityInstanceRoleArn:
    Description: Role arn used to manage the purity instance.
    Value: !GetAtt 'PurityInstanceRole.Arn'
  ReplicationEndpointCT0:
    Description: Replication IP address of the instance.
    Value: !If [IsCustomReplicationAddressCT0, !Ref 'ReplicationAddressCT0', !Select [
        0, !GetAtt 'ReplicationInterfaceCT0.SecondaryPrivateIpAddresses']]
  iSCSIEndpointCT0:
    Description: iSCSI IP address and port of the ct0 instance.
    Value: !Join ['', ['', !If [IsCustomISCSIAddressCT0, !Ref 'ISCSIAddressCT0', !Select [
            0, !GetAtt 'iSCSIInterfaceCT0.SecondaryPrivateIpAddresses']], ':3260']]
  ReplicationEndpointCT1:
    Description: Replication IP address of the instance.
    Value: !If [IsCustomReplicationAddressCT1, !Ref 'ReplicationAddressCT1', !Select [
        0, !GetAtt 'ReplicationInterfaceCT1.SecondaryPrivateIpAddresses']]
  iSCSIEndpointCT1:
    Description: iSCSI IP address and port of the ct1 instance.
    Value: !Join ['', ['', !If [IsCustomISCSIAddressCT1, !Ref 'ISCSIAddressCT1', !Select [
            0, !GetAtt 'iSCSIInterfaceCT1.SecondaryPrivateIpAddresses']], ':3260']]
  GUIEndpoint:
    Description: URL for the Purity GUI
    Value: !Join ['', ['https://', !If [IsCustomManagementAddress, !Ref 'ManagementAddress',
          !Select [0, !GetAtt 'ManagementInterfaceCT0.SecondaryPrivateIpAddresses']]]]
  ManagementEndpoint:
    Description: Management IP address of the CBS instance.
    Value: !If [IsCustomManagementAddress, !Ref 'ManagementAddress', !Select [0, !GetAtt 'ManagementInterfaceCT0.SecondaryPrivateIpAddresses']]
  ResumeLambda:
    Description: Lambda function used to resume the array.
    Value: !GetAtt 'ResumeHandler.Arn'
